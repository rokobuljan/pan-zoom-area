<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="shortcut icon" href="#!" type="image/x-icon">
    <title>Photoshop alike zoom pan area (Best) by Roko 10.2022.</title>


    <style>
        * {
            margin: 0;
            box-sizing: border-box;
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 0px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #fff;
        }

        html {
            min-height: 100%;
            background: hsl(200, 4%, 16%);
        }

        #editor {
            position: relative;
            top: 10vh;
            left: 10vw;
            width: 80vw;
            height: 80vh;
        }

        #viewport {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;

            background: hsl(200, 4%, 19%);
        }

        #canvas {
            flex: none;
            transform-origin: 50% 50%;

            background-size: 50px 50px, 50px 50px, cover;
            background-image:
                linear-gradient(to right, black 1px, transparent 1px),
                linear-gradient(to bottom, black 1px, transparent 1px),
                linear-gradient(90deg,
                    hsl(0, 100%, 50%),
                    hsl(30, 100%, 50%),
                    hsl(60, 100%, 50%),
                    hsl(90, 100%, 50%),
                    hsl(120, 100%, 50%),
                    hsl(150, 100%, 50%),
                    hsl(180, 100%, 50%),
                    hsl(210, 100%, 50%),
                    hsl(240, 100%, 50%),
                    hsl(270, 100%, 50%),
                    hsl(300, 100%, 50%),
                    hsl(330, 100%, 50%),
                    hsl(360, 100%, 50%));

        }

        .scrollTrack {
            position: absolute;
        }

        #scrollTrack-x {
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 10px;
            background: hsla(0 0% 0% / 0.2);
        }

        #scrollTrack-y {
            right: -10px;
            top: 0;
            width: 10px;
            height: 100%;
            background: hsla(0 0% 0% / 0.2);
        }

        .scrollThumb {
            background: #fffb;
            position: absolute;
        }

        #scrollTrack-x .scrollThumb {
            height: 100%;
            cursor: w-resize;
        }

        #scrollTrack-y .scrollThumb {
            width: 100%;
            cursor: s-resize;
        }

        .dot {
            width: 6px;
            height: 6px;
            margin: -3px;
            position: absolute;
            outline: 1px solid #fff;
        }
    </style>
</head>

<body>
    <div id="editor">
        <div id="viewport">
            <div id="canvas"></div>
        </div>
        <div class="scrollTrack" id="scrollTrack-x">
            <div class="scrollThumb"></div>
        </div>
        <div class="scrollTrack" id="scrollTrack-y">
            <div class="scrollThumb"></div>
        </div>
    </div>


    <script>
        const el = (sel, par) => (par || document).querySelector(sel);

        const elVpt = el("#viewport");
        const elCvs = el('#canvas');
        const elScrX = el("#scrollTrack-x");
        const elScrXThumb = el(".scrollThumb", elScrX);
        const elScrY = el("#scrollTrack-y");
        const elScrYThumb = el(".scrollThumb", elScrY);

        const offset = { x: 0, y: 0 };

        const padd = 40; // Make canvas always visible at least "padd"px

        const scaleFactor = 0.2;
        const scaleMax = 10;
        const scaleMin = 0.04;

        const canvasWidth = 400;
        const canvasHeight = 200;

        let areaWidth = 0;
        let areaHeight = 0;

        let scale = 1;
        let isPan = false;

        let isThumbDragX = false;
        let isThumbDragY = false;

        elCvs.style.width = `${canvasWidth}px`;
        elCvs.style.height = `${canvasHeight}px`;

        const changeScale = (delta) => {
            scale *= Math.exp(delta * scaleFactor);
            scale = Math.max(scaleMin, Math.min(scaleMax, scale));
            scale = +scale.toFixed(2);
        };

        const changeScaleToFit = () => {
            // Scale to fit original size (1.0) or less (with padd around viewport if needed)
            const wRatio = elVpt.clientWidth / (elCvs.clientWidth + padd * 2);
            const hRatio = elVpt.clientHeight / (elCvs.clientHeight + padd * 2);
            const fitRatio = Math.min(1, wRatio, hRatio);
            scale = +fitRatio.toFixed(1);
            applyTransform();
        };

        const fixOffset = () => {
            const bcrCvs = elCvs.getBoundingClientRect();
            const spaceX = elVpt.offsetWidth / 2 + bcrCvs.width / 2 - padd;
            const spaceY = elVpt.offsetHeight / 2 + bcrCvs.height / 2 - padd;
            offset.x = Math.max(-spaceX, Math.min(spaceX, offset.x));
            offset.y = Math.max(-spaceY, Math.min(spaceY, offset.y));
        };

        const applyScrollbars = () => {
            const bcrVpt = elVpt.getBoundingClientRect();
            const bcrCvs = elCvs.getBoundingClientRect();

            // Fictive "outer bounding area" size:
            areaWidth = (bcrVpt.width - padd) * 2 + bcrCvs.width;
            areaHeight = (bcrVpt.height - padd) * 2 + bcrCvs.height;

            const thumbSizeX = bcrVpt.width ** 2 / areaWidth;
            const thumbSizeY = bcrVpt.height ** 2 / areaHeight;
            elScrXThumb.style.width = `${thumbSizeX}px`;
            elScrYThumb.style.height = `${thumbSizeY}px`;

            const cvsRelX = bcrCvs.left - bcrVpt.left;
            const cvsRelY = bcrCvs.top - bcrVpt.top;
            const thumbPosX = (bcrVpt.width - cvsRelX - padd) / bcrVpt.width * thumbSizeX;
            const thumbPosY = (bcrVpt.height - cvsRelY - padd) / bcrVpt.height * thumbSizeY;

            elScrXThumb.style.left = `${thumbPosX}px`;
            elScrYThumb.style.top = `${thumbPosY}px`;
        };

        const applyTransform = () => {
            elCvs.style.scale = scale;
            fixOffset(); // Fix XY offset after scaling
            elCvs.style.translate = `${offset.x}px ${offset.y}px`;
            applyScrollbars();
        };

        elScrX.addEventListener("pointerdown", (evt) => {
            evt.preventDefault();
            isThumbDragX = true;
        });

        elScrY.addEventListener("pointerdown", (evt) => {
            evt.preventDefault();
            isThumbDragY = true;
        });

        addEventListener("pointermove", (evt) => {
            if (!(isThumbDragX || isThumbDragY)) {
                return;
            }
            if (isThumbDragX) {
                offset.x -= (areaWidth / elVpt.offsetWidth) * evt.movementX;
                applyTransform();
            }
            else if (isThumbDragY) {
                offset.y -= (areaHeight / elVpt.offsetHeight) * evt.movementY;
                applyTransform();
            }
        });

        elVpt.addEventListener("pointerdown", (evt) => {
            evt.preventDefault();
            isPan = true;
        });

        addEventListener("pointermove", (evt) => {
            if (!isPan || isThumbDragX) {
                return;
            }
            evt.preventDefault();
            offset.x += evt.movementX;
            offset.y += evt.movementY;
            applyTransform();
        });

        addEventListener("pointerup", (evt) => {
            isPan = false;
            isThumbDragY = false;
            isThumbDragX = false;
        });

        elVpt.addEventListener("wheel", (evt) => {
            evt.preventDefault();

            const delta = Math.sign(-evt.deltaY);
            const bcrCvs = elCvs.getBoundingClientRect();

            // Get XY coords from canvas center
            // This values are "current" (on the currently transformed #canvas)
            const x = evt.x - bcrCvs.left - bcrCvs.width / 2;
            const y = evt.y - bcrCvs.top - bcrCvs.height / 2;
            // Remember the current scale
            const scaleOld = scale;
            // Change the scale value by delta
            changeScale(delta);
            // Calculate the XY as if the element is in its
            // original, non-scaled size: 
            const xOrg = x / scaleOld;
            const yOrg = y / scaleOld;

            // Calculate the scaled XY 
            const xNew = xOrg * scale;
            const yNew = yOrg * scale;

            // Retrieve the XY difference to be used as the change in offset.
            const xDiff = x - xNew;
            const yDiff = y - yNew;

            offset.x += xDiff;
            offset.y += yDiff;

            applyTransform();

        }, { passive: false });


        addEventListener("resize", () => {
            applyTransform();
        });

        // Init:
        changeScaleToFit();
        applyScrollbars();
    </script>
</body>

</html>